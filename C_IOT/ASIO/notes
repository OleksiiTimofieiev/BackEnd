https://www.youtube.com/watch?v=rwOv_tw2eA4&t=2038s


intro:
- supports: serial ports, timers,file descriptors
- uses proactor model
- easily supports thouthands of connections
- asio::io_service == class to add work, can be run in different threads;
- strand.wrap => handle concurrency issues

buffers:
- using buffers to work with memory: mutable, const buffer
- buffers does not own the underlying data => socket_.send(...)
- scatter/gather is possible for buffers

server:
- chaining completion handlers: read async queue


details:
- io_service == intermidiate beetween program and OS
- io_objects: socket as an example
- async_operation: 
io_object
initiating function (particular class of operation)
argumetns
completion handler
- io_service::run();

optimizations:
- https://www.youtube.com/watch?v=ATT9uSD83W8
- concurrency\\coroutines
- zerocopy