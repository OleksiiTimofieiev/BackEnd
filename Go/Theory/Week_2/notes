///// async small intro
{
    - async programming
    - small cash memory
    - context switch
    - cgi-bin
    - worker pool
    - multithreading
    - most of time of the modern web api == waiting on reply from remote server, service
    ====> event driven concurrency == non-blocking i/o on one core
    - thread model == CSP (communication sequencial processing) == working with go routines
}
///// goroutines & channels
{
    - channels are used to return value from the goroutine
    - channels may be buffered or not
    - blocking until reading if not buffered channel
    - channel may be closed
    - channel may be spesialized for read/write with <- operator
    - channels shoud be closed, used to terminate cycle which iterates on channel
    - select to multiplex channels
    - channels are of FIFO queue, thread safe
    - goroutines waites for channels
    - channel: circle queue, send and recv index, lock
    - channels are allocated on heap
    - channel == kinda unix pipe, data type, write/read end
    - hint:
    type nextCh chan int
    func (ch nextCh) handler(...){
        <-ch
    }
    - channels block until ready ready to read or write
    - channel is a data type, it can be returned from a function
    - channel should be closed
    - The state of a channel can be nil, open or closed.
    - signaling without data is a single goroutine can signal many goroutines at once
    - buffered channels: Anything waiting in the buffer will be lost.
}
///// timers and timeouts
{
   - timer has a channel(timer.C) that can be passed to select to check the timeouts
   - time can be stopped, etc. 
}
///// context
{
    - stop async operations 
    - go worker(ct, i ,result...)
    - finish => signal to stop goroutine
    - can be finished by timeout
}
//// worker pool
{
    - usefull for queue processing
    - Gosched == yiel goroutine => other goroutines have possibility to work
}
///// join==wait
{
    - waitgroup
    - add before its start
}
///// limiting
{
    - quota via channel manipulations
}
///// sync
{
    - sync.Mutex: to be used by reference
    - sync.Atomic
}
/////
{
    - godoc.org
    - continuos profiling
    - code review
    - linters
    - monitoring: prometheus, gops
    - finalizers: brazil schema
    - runtime.NumGoroutine(), debug.Stack(), pprof, prometheus.io == отслеживание утекающих горутин
    - goleak, leaktest == отслеживание утекающих горутин
    - context package
    
}
///// best practices
{
    - allocate with length
    - non closed resources == defer *.Close()
    - save 2kib on stack
    - limited worker pool
    - утекающие горутины == каналы стоит закрывать
}